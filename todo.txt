# -*- mode: org; coding: utf-8-unix -*-

* bugs
* code cleanup
** isAsmParserOnly, isCodeGenOnly
what are these? skip them?

we already skip isPseudo and where Opcode is zero
** negative immediates?
is the current code ok?

find out how to properly deal with negative numbers in immediates (see
EMIT-FORMS/IMM)

#+nil(< (- (1- (expt 2 15)))
        value
        (expt 2 16))
** keep or eliminate the (bits 32) pseudo instruction?
if we get rid of the ability to switch the mode at emission time, then
we could move the 66h prefix decision to macroexpand-time.

but maybe this is needed (and nasm & co. does it like this) when e.g.
writing code that switches execution mode...?

must use a symbol-macrolet and access it through macroexpand-1 on the
&environment to retrieve it.
* knowledge base
** x86
https://www.felixcloutier.com/x86/nop
*** microarchitecture levels: x86-64-v1 .. x86-64-v4
https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels

+-----------------+---------------------------------------------------------+
| Level name      | CPU features                                            |
+-----------------+---------------------------------------------------------+
| (baseline)      | CMOV, CX8, FPU, FXSR, MMX, OSFXSR, SCE, SSE, SSE2       |
| x86-64-v2 ~2008 | LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3          |
| x86-64-v3 ~2013 | AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, OSXSAVE |
| x86-64-v4 ~2017 | AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL         |
+-----------------+---------------------------------------------------------+
*** encoding and prefixes
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp#L1555

[Prefixes][REX][VEX][Opcode][ModR/M][SIB][Displacement][Immediate]

opcode: 1-3 bytes

prefix byte order:
 - Lock/Rep → Segment → operand-size (0x66) → address-size (0x67) → opcode
 - REX comes after legacy prefixes, just before opcode.

0F: two-byte opcode escape prefix
**** ModR/M
[Mod][Reg/Opcode][R/M]

- Mod (2 bits) → addressing mode / displacement size
   00 → no displacement (except special cases)
   01 → 8-bit displacement
   10 → 32-bit displacement
   11 → operand is a register

- Reg/Opcode (3 bits) → register or opcode extension

- R/M (3 bits) → register or memory operand

000	EAX	RAX
001	ECX	RCX
010	EDX	RDX
011	EBX	RBX
100	ESP	RSP
101	EBP	RBP
110	ESI	RSI
111	EDI	RDI

Special rule:
  If Mod = 00 and R/M = 101 → RIP-relative (in 64-bit mode) or disp32 (in 32-bit mode).
**** REX (x86-64-v1)
Emit this when using 64-bit operands or registers R8–R15.

REX:  0 1 0 0 W R X B (0x4_)
W changes the operand size to 64 bits
R extra 4th bit of reg
B expands r/m (or opreg in the few opcodes that encode the register in the 3 lowest opcode bits, such as "POP reg")
X and B expand index and base in the SIB byte

REX2: 0xD5
      M0 R4 X4 B4 W R3 X3 B3
**** SIB byte
Encode SIB when memory operand uses [base + index*scale + disp]

Only when ModR/M r/m = 100 (SIB)

Scale: 00 → ×1, 01 → ×2, 10 → ×4, 11 → ×8
Index: register
Base: register or special (e.g., no base = 101)
**** Displacement
when memory addressing requires it (ModR/M indicates displacement)
Size: 1, 4, or sometimes 8 bytes (64-bit RIP-relative)

e.g.:
[RAX + 0x10] → 8-bit displacement if fits, else 32-bit
[RIP + offset] → 32-bit displacement in 64-bit mode
**** Immediate
1-8 bytes

So *InOperandList* tells you what kind of thing goes there,
  *ImmT* tells you how many bytes and with what rules to actually emit.
**** The VEX prefix (x86-64-v3)
replaces the most commonly used instruction prefix bytes and escape bytes.
https://en.wikipedia.org/wiki/VEX_prefix
https://en.wikipedia.org/wiki/VEX_prefix#REX
*** floating point registers
+----------------+-----------------+--------+-------+------------------------------+
| Register Class | Names           | Width  | Count | Encoding in Machine Code     |
+----------------+-----------------+--------+-------+------------------------------+
| x87 FPU stack  | ST(0)–ST(7)     | 80-bit |   8   | 3-bit reg field in ModR/M.   |
|                |                 |        |       | Often implicit ST(0).        |
| MMX            | MM0–MM7         | 64-bit |   8   | 3-bit reg field in ModR/M.   |
| SSE            | XMM0–XMM15      |128-bit |  16   | ModR/M + REX.R/B for ≥8.     |
| AVX            | YMM0–YMM15      |256-bit |  16   | Same as XMM, requires VEX.   |
| AVX-512        | ZMM0–ZMM31      |512-bit |  32   | EVEX extends to 5-bit regs.  |
| AVX-512 Masks  | K0–K7           |  1–64b |   8   | EVEX.aaa + ModR/M field.     |
+----------------+-----------------+--------+-------+------------------------------+

                    +--------------------+
   Operand: reg N → |  Split into fields |
                    +--------------------+
                             |
                +-----------------------------+
                | Lower 3 bits (N[2:0])       |
                | → ModR/M.reg                |
                | → ModR/M.r/m                |
                | → SIB.index                 |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3])             |
                | → REX.R (for ModR/M.reg)    |
                | → REX.B (for ModR/M.r/m)    |
                | → REX.X (for SIB.index)     |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3]) in VEX/EVEX |
                | → VEX.R / VEX.B / VEX.X     |
                |   (inverted encoding!)      |
                +-----------------------------+
                             |
                +-----------------------------+
                | High bits (N[4:5])          |
                | → EVEX.R’, EVEX.V’, EVEX.B’ |
                +-----------------------------+

** TableGen
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
*** 32/64 versions; e.g. bswap32r vs bswap64r
there are quite a few instructions in x86 where the encoding bytes are the same but the operand size / mode makes them distinct instructions in LLVM.

LLVM always “splits” them because the backend (assembler/disassembler/codegen) needs typed instruction defs (GR32 vs GR64, etc). But from an assembler author’s perspective, you could unify them into one rule keyed on operand size + mode.

complete (?) list of such instructions:
 - BSWAP
 - XCHG EAX/RAX
 - MOV reg variants
   - 8B /r (reg←r/m) and 89 /r (r/m←reg)
   - imm to reg (B8 + rd)
 - PUSH
 - POP
 - INC
 - DEC
 - MOV
 - CBW/CWDE/CDQE (98)
 - CWD/CDQ/CQO (99)

~30 instructions have 32/64-bit duplicates with identical opcode fields.
The biggest families: MOV, PUSH/POP, XCHG, INC/DEC, BSWAP, sign/zero extends.

proposed fix:
Instead of duplicating, you could:
1. Parse the opcode bytes (0F C8+rd, etc).
2. Look at operand size (r32 vs r64).
3. Emit the same opcode, with size attached.
This would let you keep a single assembler rule for bswap, push, etc.
*** json
https://llvm.org/docs/TableGen/BackEnds.html#json-reference
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp
**** *InOperandList* and *OutOperandList* order
LLVM’s InOperandList isn’t just a bag of inputs: its position in the
list tells the encoder which slot of the instruction encoding this
operand occupies. Each slot corresponds to a different machine-code
field (ModR/M, immediate, displacement, prefix bits, …).

1. Parse operands based on AsmString, not by concatenating lists.
 - Use the $operandName placeholders in AsmString to decide which operands are explicit.
 - Match $operandName back to entries in InOperandList or OutOperandList.

2. Implicit outs (like EFLAGS, implicit registers) → ignore them in parsing, but keep them in metadata if you want to support analysis later.

3. Explicit outs (like $dst in imul) → treat them as user-supplied operands, even though they live in OutOperandList.

OutOperandList = what instruction defines.
InOperandList = what instruction uses.
AsmString = the true key telling you which operands actually show up in assembly text.

For assembling, you follow AsmString. For encoding, you look up operand info by name.
**** AsmString
imul{w}: mnemonic, possibly with suffixes.

    {w} means “word size” → in AT&T syntax, w indicates 16-bit.

    The braces are substitution markers for things like {b}, {w}, {l}, {q}, depending on operand size.

\t: literal tab character for spacing.

{ ... | ... }: this is where Intel vs AT&T dialects differ.

    Left side of | = AT&T syntax.

    Right side of | = Intel syntax.


{$src2, $src1, $dst | $dst, $src1, $src2}
Operands are referenced by name, e.g. $src1, $src2, $dst.
 - These names come from InOperandList and OutOperandList.

Order matters:
 - AT&T syntax → $src2, $src1, $dst
 - Intel syntax → $dst, $src1, $src2

This matches the conventions of each dialect:
 - AT&T: destination is last.
 - Intel: destination is first.

***** DONE corner cases to deal with
****** {${mask}}{z}
"v4fmaddps	{$src3, $src2, $dst {${mask}}|$dst {${mask}}, $src2, $src3}"
"v4fmaddps	{$src3, $src2, $dst {${mask}} {z}|$dst {${mask}} {z}, $src2, $src3}"
${mask} is an optional mask register (k0–k7).
{z} optional keyword when the instruction supports the “zeroing” feature.
****** {1to8}
"vaddbf16	{${src2}{1to8}, $src1, $dst {${mask}} {z}|$dst {${mask}} {z}, $src1, ${src2}{1to8}}"
${src2}{1to8} → broadcast form of a memory operand
  - Meaning: take a scalar memory element and replicate (broadcast) it across all lanes of the destination vector.
{1to16}
{1to32}
(vaddbf16 dst src1 (broadcast src2 :factor 8) &optional mask zeroing?)
encoding:
 broadcast → encoded in EVEX.b + SAE bits, etc.
 mask → EVEX.aaa
 zeroing → EVEX.Z

hints in json, operand types:
 src2 of type bcst / i16mem_bcst / f32mem_bcst etc.
 i16mem (normal memory)
 i16mem_bcst (broadcast-capable memory)
 That _bcst suffix is the canonical hint that the operand can accept {1toN}.
****** {sae}
"vcmppd	{$cc, {sae}, $src2, $src1, $dst|$dst, $src1, $src2, {sae}, $cc}"

In TableGen, {sae} comes from special AsmOperandClass (like SAE or EVEX_SAE)
It’s basically a flag → if present, set an EVEX bit (EVEX.b = 1) in the final encoding.
**** FormBits and form
is a bitmask representing properties of the instruction’s operand layout.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrFormats.td
https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/X86RecognizableInstr.h#L99

enum {
  Pseudo          = 0,
  RawFrm          = 1,
  AddRegFrm       = 2, // add register into the 3 low bits of the opcode
  RawFrmMemOffs   = 3,
  RawFrmSrc       = 4,
  RawFrmDst       = 5,
  RawFrmDstSrc    = 6,
  RawFrmImm8      = 7,
  RawFrmImm16     = 8,
  MRMDestMem      = 32,
  MRMSrcMem       = 33,
  MRMSrcMem4VOp3  = 34,
  MRMSrcMemOp4    = 35,
  MRMXm           = 39,
  MRM0m..MRM7m    = 40..47,
  MRMDestReg      = 48,
  MRMSrcReg       = 49,
  MRMSrcReg4VOp3  = 50,
  MRMSrcRegOp4    = 51,
  MRMXr           = 55,
  MRM0r..MRM7r    = 56..63,
  // ... followed by MRM_C0..MRM_FF for hex opcode forms 64..126 etc.
};

***** decoding table
RawFrm family (implied / fixed operands)
| Form              | Example Mnemonics                     | Meaning for assembler generator                        | What to do with JSON operands |
| ----------------- | ------------------------------------- | ------------------------------------------------------ | ----------------------------- |
| **RawFrm**        | `nop`, `clc`, `cbw`, `cdq`            | Pure opcode, no operands.                              | Ignore `$src`/`$dst`.         |
| **RawFrmImm8**    | `int imm8`, `enter imm16, imm8`       | Has 8-bit immediate.                                   | Keep `i8imm`.                 |
| **RawFrmImm16**   | `enter imm16, imm8` (imm16 part)      | Has 16-bit immediate.                                  | Keep `i16imm`.                |
| **RawFrmImm32**   | Far `call imm32`, `jmp imm32`         | Has 32-bit immediate.                                  | Keep `i32imm`.                |
| **RawFrmDstSrc**  | `cmpsb/w/d/q`, `movsb/w/d/q`          | No explicit operands: implicit `(E)SI→(E)DI`.          | Ignore `$src`/`$dst`.         |
| **RawFrmDst**     | `stosb/w/d/q`, `scasb/w/d/q`          | No explicit operands: implicit `AL/AX/EAX` → `[EDI]`.  | Ignore `$dst`.                |
| **RawFrmSrc**     | `lodsb/w/d/q`                         | No explicit operands: implicit `[ESI]` → `AL/AX/EAX`.  | Ignore `$src`.                |
| **RawFrmMemOffs** | `mov al, [imm32]`, `mov [imm32], eax` | Memory is encoded as absolute displacement, no ModR/M. | Keep `offset32`.              |


MRM family (special ModR/M encodings; the instruction is distinguished by the ModR/M reg field (bits 3–5), not by opcode alone.)
| Form              | Example Mnemonics            | Meaning                                                      | Assembler generator action                                              |
| ----------------- | ---------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------------------- |
| **MRM0r–MRM7r**   | `TEST r/m32, r32` variants   | The `/r` field in ModR/M is used as opcode extension 0–7.    | JSON already expands them. Treat like normal ModR/M form.               |
| **MRM0m–MRM7m**   | `TEST r/m8, imm8` (etc.)     | Same as above, but operand is memory.                        | Normal ModR/M handling.                                                 |
| **MRM\_C0**       | `xlat`, some `FPU` ops       | Fixed reg field = `000b`. No explicit operand.               | Assembler should expose zero operands.                                  |
| **MRM\_0F**       | All `0F xx` two-byte opcodes | Means this opcode uses `0F` escape prefix.                   | Treat normally; JSON gives operands.                                    |
| **MRM\_C1, C2 …** | Many FPU instructions        | Opcode group distinguished by ModR/M reg field = 001b, 010b… | Usually no operands (implicit ST registers). Ignore JSON `$src`/`$dst`. |


others:
| Form                 | Example Mnemonics                        | Meaning                                                        | Assembler action                                      |
| -------------------- | ---------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------- |
| **MRM\_C8 … CF**     | FPU register stack ops like `fxch st(i)` | Operands encoded in ModR/M reg field, but always ST registers. | Sometimes JSON shows `dstidx8/srcidx8`. Map to ST(i). |
| **MRM\_Int**         | `INT imm8`                               | Encoded with opcode `CD` + imm8.                               | Same as RawFrmImm8 (alias).                           |
| **MRM\_SI/DI**       | `MOVS`, `CMPS`, etc.                     | Implied source/dest pointers (string ops).                     | Same as RawFrmDst/Src.                                |
| **MRM\_Op3A, Op3B…** | `0F 3A xx`, `0F 3B xx`                   | Extra opcode map (VEX/SSSE3 instructions).                     | Normal operand handling; prefix distinguishes them.   |
***** etc
1. Raw Forms (no ModR/M):
   RawFrm, RawFrmMemOffs, RawFrmSrc, RawFrmDst, RawFrmDstSrc, RawFrmImm8, RawFrmImm16: used for immediate forms or memory offsets without ModR/M.

2. AddReg Forms:
   AddRegFrm: register encoded in low opcode bits (e.g., INC r, DEC r).

3. ModR/M Forms:
   MRMDestMem, MRMSrcMem, MRMDestReg, MRMSrcReg, plus their vector extensions (4VOp3, Op4).

4. Fixed opcode forms (/digit or fixed Reg in ModR/M):

   MRM0m–MRM7m, MRM0r–MRM7r: where /0.../7 are fixed sub-opcode encodings.
   And MRMXm, MRMXr: extended mappings.
   Plus MRM_C0..MRM_FF: hard-coded 2nd opcode or reg field mapping.
**** TSFlags
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h#L692

(set-flag :form-bits  (pop-bits 7)) ; 0-7
(set-flag :op-size    (pop-bits 2)) ; 8-9
(set-flag :ad-size    (pop-bits 2)) ; 10-11
(set-flag :op-prefix  (pop-bits 2)) ; 12-13
(set-flag :op-map     (pop-bits 4)) ; 14-17
(set-flag :rex        (pop-bits 1)) ; 18
(set-flag :imm        (pop-bits 4)) ; 19-22
(set-flag :fp-type    (pop-bits 3)) ; 23-25
(set-flag :lock       (pop-bits 1)) ; 26
(set-flag :rep        (pop-bits 1)) ; 27
(set-flag :sse-domain (pop-bits 2)) ; 28-29
(set-flag :encoding   (pop-bits 2)) ; 30-31
(let ((opcode (pop-bits 8)))        ; 32-39
  ;; assert that the extracted json opcode is the same as the
  ;; one encoded into the tsflags.
  (assert (equal opcode (get-field :opcode))))

;; :vector contains all the rest of the flags for easy checking for complex instructions
(set-flag :vector     (json-bitfield-to-integer tsflags)) ; 40-

(set-flag :vex-4v     (pop-bits 1))
(set-flag :vex-l      (pop-bits 1))
(set-flag :evex-k     (pop-bits 1))
(set-flag :evex-z     (pop-bits 1))
(set-flag :evex-l2    (pop-bits 1))
(set-flag :evex-b     (pop-bits 1))
(set-flag :cd8-scale  (pop-bits 3))
(set-flag :evex-rc    (pop-bits 1))
(set-flag :no-track   (pop-bits 1))
(set-flag :explicit-op-prefix (pop-bits 2))
(set-flag :evex-nf    (pop-bits 1))
(set-flag :two-conditional (pop-bits 1))
(set-flag :evex-u     (pop-bits 1))
**** X86II::getOperandBias(Desc)
returns an integer offset telling the emitter where the first “real” operand starts in the instruction’s operand list.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrInfo.cpp
**** corner cases
***** constraints
search for: constraints": "[^"]
		"!name": "ADC32rr_REV",
		"Constraints": "$src1 = $dst",
**** parsing json
streaming API is a must because the file is 147MB (222 pretty printed)
 which disqualifies most CL json parsers

https://sabracrolleton.github.io/json-review#decoding
https://github.com/sabracrolleton/sabracrolleton.github.io/

probably i should have picked this one instead of json-streams:
https://github.com/Zulu-Inuoe/jzon#streaming-parser-example
*** fake instructions
ADDR16_PREFIX
LOCK_PREFIX
REP_PREFIX
REPE_PREFIX
REPNE_PREFIX
DATA16_PREFIX
CS_PREFIX
DS_PREFIX
FS_PREFIX
GS_PREFIX
SS_PREFIX
* etc
** interested parties
https://github.com/phantomics/specops/discussions/2
** useful #command lines
echo -n 'f3 90' | xxd -r -p | ndisasm -b 64 -
cat test.asm && nasm test.asm && hexdump --canonical test
