# -*- mode: org; coding: utf-8-unix -*-

* bugs
* code cleanup
** isAsmParserOnly, isCodeGenOnly
what are these? skip them?

we already skip isPseudo and where Opcode is zero
* knowledge base
** x86
https://www.felixcloutier.com/x86/nop
*** microarchitecture levels: x86-64-v1 .. x86-64-v4
https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels

+-----------------+---------------------------------------------------------+
| Level name      | CPU features                                            |
+-----------------+---------------------------------------------------------+
| (baseline)      | CMOV, CX8, FPU, FXSR, MMX, OSFXSR, SCE, SSE, SSE2       |
| x86-64-v2 ~2008 | LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3          |
| x86-64-v3 ~2013 | AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, OSXSAVE |
| x86-64-v4 ~2017 | AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL         |
+-----------------+---------------------------------------------------------+
*** encoding and prefixes
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp#L1555

[Prefixes][REX][VEX][Opcode][ModR/M][SIB][Displacement][Immediate]

opcode: 1-3 bytes

prefix byte order:
 - Lock/Rep → Segment → operand-size (0x66) → address-size (0x67) → opcode
 - REX comes after legacy prefixes, just before opcode.

0F: two-byte opcode escape prefix
**** ModR/M
[Mod][Reg/Opcode][R/M]

- Mod (2 bits) → addressing mode / displacement size
   00 → no displacement (except special cases)
   01 → 8-bit displacement
   10 → 32-bit displacement
   11 → operand is a register

- Reg/Opcode (3 bits) → register or opcode extension

- R/M (3 bits) → register or memory operand

000	EAX	RAX
001	ECX	RCX
010	EDX	RDX
011	EBX	RBX
100	ESP	RSP
101	EBP	RBP
110	ESI	RSI
111	EDI	RDI

Special rule:
  If Mod = 00 and R/M = 101 → RIP-relative (in 64-bit mode) or disp32 (in 32-bit mode).
**** REX (x86-64-v1)
Emit this when using 64-bit operands or registers R8–R15.

REX:  0 1 0 0 W R X B (0x4_)
W changes the operand size to 64 bits
R expands reg to 4 bits
B expands r/m (or opreg in the few opcodes that encode the register in the 3 lowest opcode bits, such as "POP reg")
X and B expand index and base in the SIB byte

REX2: 0xD5
      M0 R4 X4 B4 W R3 X3 B3
**** SIB byte
Encode SIB when memory operand uses [base + index*scale + disp]

Only when ModR/M r/m = 100 (SIB)

Scale: 00 → ×1, 01 → ×2, 10 → ×4, 11 → ×8
Index: register
Base: register or special (e.g., no base = 101)
**** Displacement
when memory addressing requires it (ModR/M indicates displacement)
Size: 1, 4, or sometimes 8 bytes (64-bit RIP-relative)

e.g.:
[RAX + 0x10] → 8-bit displacement if fits, else 32-bit
[RIP + offset] → 32-bit displacement in 64-bit mode
**** Immediate
1-8 bytes
**** The VEX prefix (x86-64-v3)
replaces the most commonly used instruction prefix bytes and escape bytes.
https://en.wikipedia.org/wiki/VEX_prefix
https://en.wikipedia.org/wiki/VEX_prefix#REX
*** floating point registers
+----------------+-----------------+--------+-------+------------------------------+
| Register Class | Names           | Width  | Count | Encoding in Machine Code     |
+----------------+-----------------+--------+-------+------------------------------+
| x87 FPU stack  | ST(0)–ST(7)     | 80-bit |   8   | 3-bit reg field in ModR/M.   |
|                |                 |        |       | Often implicit ST(0).        |
| MMX            | MM0–MM7         | 64-bit |   8   | 3-bit reg field in ModR/M.   |
| SSE            | XMM0–XMM15      |128-bit |  16   | ModR/M + REX.R/B for ≥8.     |
| AVX            | YMM0–YMM15      |256-bit |  16   | Same as XMM, requires VEX.   |
| AVX-512        | ZMM0–ZMM31      |512-bit |  32   | EVEX extends to 5-bit regs.  |
| AVX-512 Masks  | K0–K7           |  1–64b |   8   | EVEX.aaa + ModR/M field.     |
+----------------+-----------------+--------+-------+------------------------------+

                    +--------------------+
   Operand: reg N → |  Split into fields |
                    +--------------------+
                             |
                +-----------------------------+
                | Lower 3 bits (N[2:0])       |
                | → ModR/M.reg                |
                | → ModR/M.r/m                |
                | → SIB.index                 |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3])             |
                | → REX.R (for ModR/M.reg)    |
                | → REX.B (for ModR/M.r/m)    |
                | → REX.X (for SIB.index)     |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3]) in VEX/EVEX |
                | → VEX.R / VEX.B / VEX.X     |
                |   (inverted encoding!)      |
                +-----------------------------+
                             |
                +-----------------------------+
                | High bits (N[4:5])          |
                | → EVEX.R’, EVEX.V’, EVEX.B’ |
                +-----------------------------+

** TableGen
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
*** 32/64 versions; e.g. bswap32r vs bswap64r
there are quite a few instructions in x86 where the encoding bytes are the same but the operand size / mode makes them distinct instructions in LLVM.

LLVM always “splits” them because the backend (assembler/disassembler/codegen) needs typed instruction defs (GR32 vs GR64, etc). But from an assembler author’s perspective, you could unify them into one rule keyed on operand size + mode.

complete (?) list of such instructions:
 - BSWAP
 - XCHG EAX/RAX
 - MOV reg variants
   - 8B /r (reg←r/m) and 89 /r (r/m←reg)
   - imm to reg (B8 + rd)
 - PUSH
 - POP
 - INC
 - DEC
 - MOV
 - CBW/CWDE/CDQE (98)
 - CWD/CDQ/CQO (99)

~30 instructions have 32/64-bit duplicates with identical opcode fields.
The biggest families: MOV, PUSH/POP, XCHG, INC/DEC, BSWAP, sign/zero extends.

proposed fix:
Instead of duplicating, you could:
1. Parse the opcode bytes (0F C8+rd, etc).
2. Look at operand size (r32 vs r64).
3. Emit the same opcode, with size attached.
This would let you keep a single assembler rule for bswap, push, etc.
*** json
https://llvm.org/docs/TableGen/BackEnds.html#json-reference
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp
**** FormBits
is a bitmask representing properties of the instruction’s operand layout.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrFormats.td
https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/X86RecognizableInstr.h#L99

enum {
  Pseudo          = 0,
  RawFrm          = 1,
  AddRegFrm       = 2, // add register into the 3 low bits of the opcode
  RawFrmMemOffs   = 3,
  RawFrmSrc       = 4,
  RawFrmDst       = 5,
  RawFrmDstSrc    = 6,
  RawFrmImm8      = 7,
  RawFrmImm16     = 8,
  MRMDestMem      = 32,
  MRMSrcMem       = 33,
  MRMSrcMem4VOp3  = 34,
  MRMSrcMemOp4    = 35,
  MRMXm           = 39,
  MRM0m..MRM7m    = 40..47,
  MRMDestReg      = 48,
  MRMSrcReg       = 49,
  MRMSrcReg4VOp3  = 50,
  MRMSrcRegOp4    = 51,
  MRMXr           = 55,
  MRM0r..MRM7r    = 56..63,
  // ... followed by MRM_C0..MRM_FF for hex opcode forms 64..126 etc.
};

1. Raw Forms (no ModR/M):
   RawFrm, RawFrmMemOffs, RawFrmSrc, RawFrmDst, RawFrmDstSrc, RawFrmImm8, RawFrmImm16: used for immediate forms or memory offsets without ModR/M.

2. AddReg Forms:
   AddRegFrm: register encoded in low opcode bits (e.g., INC r, DEC r).

3. ModR/M Forms:
   MRMDestMem, MRMSrcMem, MRMDestReg, MRMSrcReg, plus their vector extensions (4VOp3, Op4).

4. Fixed opcode forms (/digit or fixed Reg in ModR/M):

   MRM0m–MRM7m, MRM0r–MRM7r: where /0.../7 are fixed sub-opcode encodings.
   And MRMXm, MRMXr: extended mappings.
   Plus MRM_C0..MRM_FF: hard-coded 2nd opcode or reg field mapping.
**** TSFlags
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h#L692

(set-flag :form-bits  (pop-bits 7)) ; 0-7
(set-flag :op-size    (pop-bits 2)) ; 8-9
(set-flag :ad-size    (pop-bits 2)) ; 10-11
(set-flag :op-prefix  (pop-bits 2)) ; 12-13
(set-flag :op-map     (pop-bits 4)) ; 14-17
(set-flag :rex        (pop-bits 1)) ; 18
(set-flag :imm        (pop-bits 4)) ; 19-22
(set-flag :fp-type    (pop-bits 3)) ; 23-25
(set-flag :lock       (pop-bits 1)) ; 26
(set-flag :rep        (pop-bits 1)) ; 27
(set-flag :sse-domain (pop-bits 2)) ; 28-29
(set-flag :encoding   (pop-bits 2)) ; 30-31
(let ((opcode (pop-bits 8)))        ; 32-39
  ;; assert that the extracted json opcode is the same as the
  ;; one encoded into the tsflags.
  (assert (equal opcode (get-field :opcode))))

;; :vector contains all the rest of the flags for easy checking for complex instructions
(set-flag :vector     (json-bitfield-to-integer tsflags)) ; 40-

(set-flag :vex-4v     (pop-bits 1))
(set-flag :vex-l      (pop-bits 1))
(set-flag :evex-k     (pop-bits 1))
(set-flag :evex-z     (pop-bits 1))
(set-flag :evex-l2    (pop-bits 1))
(set-flag :evex-b     (pop-bits 1))
(set-flag :cd8-scale  (pop-bits 3))
(set-flag :evex-rc    (pop-bits 1))
(set-flag :no-track   (pop-bits 1))
(set-flag :explicit-op-prefix (pop-bits 2))
(set-flag :evex-nf    (pop-bits 1))
(set-flag :two-conditional (pop-bits 1))
(set-flag :evex-u     (pop-bits 1))
**** X86II::getOperandBias(Desc)
returns an integer offset telling the emitter where the first “real” operand starts in the instruction’s operand list.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrInfo.cpp
**** corner cases
***** constraints
search for: constraints": "[^"]
		"!name": "ADC32rr_REV",
		"Constraints": "$src1 = $dst",
**** parsing json
streaming API is a must because the file is 147MB (222 pretty printed)
 which disqualifies most CL json parsers

https://sabracrolleton.github.io/json-review#decoding
https://github.com/sabracrolleton/sabracrolleton.github.io/

probably i should have picked this one instead of json-streams:
https://github.com/Zulu-Inuoe/jzon#streaming-parser-example
*** fake instructions
ADDR16_PREFIX
LOCK_PREFIX
REP_PREFIX
REPE_PREFIX
REPNE_PREFIX
DATA16_PREFIX
CS_PREFIX
DS_PREFIX
FS_PREFIX
GS_PREFIX
SS_PREFIX
* etc
** interested parties
https://github.com/phantomics/specops/discussions/2
** useful #command lines
echo -n 'f3 90' | xxd -r -p | ndisasm -b 64 -
cat test.asm && nasm test.asm && hexdump --canonical test
