# -*- mode: org; coding: utf-8-unix -*-

* bugs
* code cleanup
** isAsmParserOnly, isCodeGenOnly
what are these? skip them?

we already skip isPseudo and where Opcode is zero
** negative immediates?
is the current code ok?

find out how to properly deal with negative numbers in immediates (see
EMIT-FORMS/IMM)

#+nil(< (- (1- (expt 2 15)))
        value
        (expt 2 16))
** keep or eliminate the (bits 32) pseudo instruction?
if we get rid of the ability to switch the mode at emission time, then
we could move the 66h prefix decision to macroexpand-time.

but maybe this is needed (and nasm & co. does it like this) when e.g.
writing code that switches execution mode...?

must use a symbol-macrolet and access it through macroexpand-1 on the
&environment to retrieve it.
** architectural headache around staging computation; add a functional interface
sometimes DECODE-REGISTER wants to dispatch on the
CURRENT-EXECUTION-MODE (GR32orGR64 operand types), but that is only
available at runtime.

moving the D-R call into the expansion would be a costy code reorg.

consider using a small partial-eval and constructing the entire
instruction emit form and let the p-e deal with all this.

this is related to adding a functional interface where the register
name is passed as a function argument at runtime.
* features
** partition instructions by microarchitecture levels?
or maybe add the predicates to the asm-context for runtime checks?
* knowledge base
** x86
https://www.felixcloutier.com/x86/nop
*** microarchitecture levels: x86-64-v1 .. x86-64-v4
https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels

+-----------------+---------------------------------------------------------+
| Level name      | CPU features                                            |
+-----------------+---------------------------------------------------------+
| (baseline)      | CMOV, CX8, FPU, FXSR, MMX, OSFXSR, SCE, SSE, SSE2       |
| x86-64-v2 ~2008 | LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3          |
| x86-64-v3 ~2013 | AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, OSXSAVE |
| x86-64-v4 ~2017 | AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL         |
+-----------------+---------------------------------------------------------+
*** #registers
| 64-bit | 32-bit   | 16-bit   | 8-bit (low) | 8-bit (high / special) |
| ------ | -------- | -------- | ----------- | ---------------------- |
| RAX    | EAX      | AX       | AL          | AH (no REX)            |
| RBX    | EBX      | BX       | BL          | BH (no REX)            |
| RCX    | ECX      | CX       | CL          | CH (no REX)            |
| RDX    | EDX      | DX       | DL          | DH (no REX)            |
| RSI    | ESI      | SI       | SIL (REX)   | —                      |
| RDI    | EDI      | DI       | DIL (REX)   | —                      |
| RBP    | EBP      | BP       | BPL (REX)   | —                      |
| RSP    | ESP      | SP       | SPL (REX)   | —                      |
| R8–R15 | R8D–R15D | R8W–R15W | R8B–R15B    | —                      |

x87 FPU stack (mostly obsolete):
 - 8 registers: ST(0)–ST(7)
 - 80-bit internally, addressable as 32/64/80 bits depending on instruction.
 - Mostly legacy by now

MMX registers (Obsolete, replaced by XMM/YMM/ZMM.):
 - MM0–MM7 (64-bit)
 - Aliases of ST(0)–ST(7)

SSE / AVX:
 - XMM0–XMM15: 128-bit (SSE/AVX base)
 - YMM0–YMM15: 256-bit (AVX)
 - ZMM0–ZMM31: 512-bit (AVX-512)
 - Lower halves alias (ZMM → YMM → XMM).

Mask registers (AVX-512):
 - K0–K7 (or K0–K31 with EVEX) — 64-bit masks used for predication.

Control Registers (control_reg):
 - CR0, CR2, CR3, CR4, CR8 (64-bit mode).
 - CR1, CR5–CR7 are reserved/unused.
 - Used for paging, system control, etc.

Debug Registers (debug_reg):
 - DR0–DR7, DR8–DR15 (depending on CPU).
 - Used for hardware breakpoints, debugging.

System Registers:
 - GDTR, IDTR — descriptor table registers
 - LDTR, TR — task register and local descriptor table
 - MSRs (Model Specific Registers) — accessible with RDMSR / WRMSR
*** encoding and prefixes
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp#L1555

[Prefixes][REX][VEX][Opcode][ModR/M][SIB][Displacement][Immediate]

opcode: 1-3 bytes

prefix byte order:
 - Lock/Rep → Segment → operand-size (0x66) → address-size (0x67) → opcode
 - REX comes after legacy prefixes, just before opcode.

0F: two-byte opcode escape prefix
**** ModR/M
+---+---+---+---+---+---+---+---+
|   mod   |   reg/opcode  | r/m |
+---+---+---+---+---+---+---+---+
  7   6     5   4   3     2   1 0

- mod (2 bits): addressing mode (register, memory, disp8, disp32, etc.)
- reg/opcode (3 bits):
  Normally selects a register operand.
  But in some opcodes, it’s treated as an opcode extension — this is where the /r vs /digit notation comes in.
- r/m (3 bits): register or memory operand (sometimes extended with SIB if r/m=100).

/r → The instruction has a register operand encoded in the reg field of ModR/M.
/digit (like /0, /1, … /7) → The reg field is not a register but an opcode extension.


000	EAX	RAX
001	ECX	RCX
010	EDX	RDX
011	EBX	RBX
100	ESP	RSP
101	EBP	RBP
110	ESI	RSI
111	EDI	RDI

Special rule:
  If Mod = 00 and R/M = 101 → RIP-relative (in 64-bit mode) or disp32 (in 32-bit mode).
**** REX (x86-64-v1)
Emit this when using 64-bit operands or registers R8–R15.

REX:  0 1 0 0 W R X B (0x4_)
0 REX.B 4th bit of modrm.r/m (or opreg in the few opcodes that encode the register in the 3 lowest opcode bits, such as "POP reg")
1 REX.X and B expand index and base in the SIB byte
2 REX.R 4th bit of modrm.reg
3 REX.W changes the operand size to 64 bits

REX2: 0xD5
      M0 R4 X4 B4 W R3 X3 B3
**** SIB byte
Encode SIB when memory operand uses [base + index*scale + disp]

Only when ModR/M r/m = 100 (SIB)

Scale: 00 → ×1, 01 → ×2, 10 → ×4, 11 → ×8
Index: register
Base: register or special (e.g., no base = 101)
**** Displacement
when memory addressing requires it (ModR/M indicates displacement)
Size: 1, 4, or sometimes 8 bytes (64-bit RIP-relative)

e.g.:
[RAX + 0x10] → 8-bit displacement if fits, else 32-bit
[RIP + offset] → 32-bit displacement in 64-bit mode
**** Immediate
1-8 bytes

So *InOperandList* tells you what kind of thing goes there,
  *ImmT* tells you how many bytes and with what rules to actually emit.
**** The VEX prefix (x86-64-v3)
replaces the most commonly used instruction prefix bytes and escape bytes.
https://en.wikipedia.org/wiki/VEX_prefix
https://en.wikipedia.org/wiki/VEX_prefix#REX
*** floating point registers
+----------------+-----------------+--------+-------+------------------------------+
| Register Class | Names           | Width  | Count | Encoding in Machine Code     |
+----------------+-----------------+--------+-------+------------------------------+
| x87 FPU stack  | ST(0)–ST(7)     | 80-bit |   8   | 3-bit reg field in ModR/M.   |
|                |                 |        |       | Often implicit ST(0).        |
| MMX            | MM0–MM7         | 64-bit |   8   | 3-bit reg field in ModR/M.   |
| SSE            | XMM0–XMM15      |128-bit |  16   | ModR/M + REX.R/B for ≥8.     |
| AVX            | YMM0–YMM15      |256-bit |  16   | Same as XMM, requires VEX.   |
| AVX-512        | ZMM0–ZMM31      |512-bit |  32   | EVEX extends to 5-bit regs.  |
| AVX-512 Masks  | K0–K7           |  1–64b |   8   | EVEX.aaa + ModR/M field.     |
+----------------+-----------------+--------+-------+------------------------------+

                    +--------------------+
   Operand: reg N → |  Split into fields |
                    +--------------------+
                             |
                +-----------------------------+
                | Lower 3 bits (N[2:0])       |
                | → ModR/M.reg                |
                | → ModR/M.r/m                |
                | → SIB.index                 |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3])             |
                | → REX.R (for ModR/M.reg)    |
                | → REX.B (for ModR/M.r/m)    |
                | → REX.X (for SIB.index)     |
                +-----------------------------+
                             |
                +-----------------------------+
                |  4th bit (N[3]) in VEX/EVEX |
                | → VEX.R / VEX.B / VEX.X     |
                |   (inverted encoding!)      |
                +-----------------------------+
                             |
                +-----------------------------+
                | High bits (N[4:5])          |
                | → EVEX.R’, EVEX.V’, EVEX.B’ |
                +-----------------------------+

** arm (aarch64)
- Fixed width: All instructions are 32 bits wide. (Contrast with ARMv7 which had 16/32-bit Thumb mixes.)
- Structured fields: Instructions are divided into major classes based on a top set of opcode bits. These high-order bits effectively define a decoder space.
- Orthogonality: Within each class, operand fields (registers, immediates, shifts) tend to sit in consistent bit positions.

ARM defines the encoding space by the top 11 bits of the instruction word (op[31:21]). These select a major opcode group:
 - Data Processing – Immediate
 - Branch, Exception, and System
 - Loads and Stores
 - Data Processing – Register
 - Floating-point / Advanced SIMD
 - Reserved/other
Each group subdivides further based on sub-opcodes.

5-bit register fields → support up to 32 architectural registers (X0–X30, plus SP/ZR special cases).
Encoding reuses the same 5-bit field for integer and FP registers, context decides interpretation.
Special registers (e.g. SP) are often encoded as 11111.

Endianness: AArch64 supports both little and big endian, but in practice, little-endian dominates and will continue to.
*** instruction anatomy
31   30   29  28..24  23..22  21..10  9..5  4..0
sf | op | S | 10001  | sh    | imm12 | Rn  | Rd
sf (bit 31): 0 = 32-bit op, 1 = 64-bit op

op (bit 30): 0 = ADD, 1 = SUB
S (bit 29): 0 = normal, 1 = set flags (ADDS/SUBS)
10001 (bits 28..24): fixed pattern
sh (bits 23..22): shift amount (0 = no shift, 1 = LSL12)
imm12 (bits 21..10): 12-bit unsigned immediate
Rn (bits 9..5): source register
Rd (bits 4..0): destination register
*** Immediates
ARM encodings are compact but have lots of “shaped immediates”:
 - Logical immediates: encoded as a bitmask pattern (N:immr:imms). This encodes values like 0x00FF00FF.
 - Add/sub immediates: 12-bit unsigned immediate with an optional shift by 12.
 - Branch immediates: signed, PC-relative, width depends on branch type (e.g. 26-bit for B/BL, 19-bit for conditional).
 - Move wide immediates (MOVZ/MOVN/MOVK): 16-bit immediate plus a 2-bit shift (positioning a halfword).
*** ARM TableGen
Encoding tables from LLVM: TableGen already maps each instruction mnemonic to bit patterns + operand kinds. You’ll mostly need to implement operand encoders (e.g. how to transform an arbitrary constant into the N:immr:imms fields).

Consistency: Register fields are always 5 bits, branch displacements are always PC-relative, shifts are limited and encoded in small fields.

Aliases: Many ARM mnemonics are aliases (MOV → ORR with zero register). Decide early if you want to expose canonical encodings only, or handle aliases.

Scalability: ARM keeps extending the architecture (SVE, SME, pointer auth, MTE). The base encoding model doesn’t change — still 32-bit instructions, still slotting into the same high-level opcode groups. Future features just eat more of the currently “reserved” spaces.
** TableGen
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
*** 32/64 versions; e.g. bswap32r vs bswap64r
there are quite a few instructions in x86 where the encoding bytes are the same but the operand size / mode makes them distinct instructions in LLVM.

LLVM always “splits” them because the backend (assembler/disassembler/codegen) needs typed instruction defs (GR32 vs GR64, etc). But from an assembler author’s perspective, you could unify them into one rule keyed on operand size + mode.

complete (?) list of such instructions:
 - BSWAP
 - XCHG EAX/RAX
 - MOV reg variants
   - 8B /r (reg←r/m) and 89 /r (r/m←reg)
   - imm to reg (B8 + rd)
 - PUSH
 - POP
 - INC
 - DEC
 - MOV
 - CBW/CWDE/CDQE (98)
 - CWD/CDQ/CQO (99)

~30 instructions have 32/64-bit duplicates with identical opcode fields.
The biggest families: MOV, PUSH/POP, XCHG, INC/DEC, BSWAP, sign/zero extends.

proposed fix:
Instead of duplicating, you could:
1. Parse the opcode bytes (0F C8+rd, etc).
2. Look at operand size (r32 vs r64).
3. Emit the same opcode, with size attached.
This would let you keep a single assembler rule for bswap, push, etc.
*** json
https://llvm.org/docs/TableGen/BackEnds.html#json-reference
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp
**** *InOperandList* and *OutOperandList* order
LLVM’s InOperandList isn’t just a bag of inputs: its position in the
list tells the encoder which slot of the instruction encoding this
operand occupies. Each slot corresponds to a different machine-code
field (ModR/M, immediate, displacement, prefix bits, …).

1. Parse operands based on AsmString, not by concatenating lists.
 - Use the $operandName placeholders in AsmString to decide which operands are explicit.
 - Match $operandName back to entries in InOperandList or OutOperandList.

2. Implicit outs (like EFLAGS, implicit registers) → ignore them in parsing, but keep them in metadata if you want to support analysis later.

3. Explicit outs (like $dst in imul) → treat them as user-supplied operands, even though they live in OutOperandList.

OutOperandList = what instruction defines.
InOperandList = what instruction uses.
AsmString = the true key telling you which operands actually show up in assembly text.

For assembling, you follow AsmString. For encoding, you look up operand info by name.
**** AsmString
imul{w}: mnemonic, possibly with suffixes.

    {w} means “word size” → in AT&T syntax, w indicates 16-bit.

    The braces are substitution markers for things like {b}, {w}, {l}, {q}, depending on operand size.

\t: literal tab character for spacing.

{ ... | ... }: this is where Intel vs AT&T dialects differ.

    Left side of | = AT&T syntax.

    Right side of | = Intel syntax.


{$src2, $src1, $dst | $dst, $src1, $src2}
Operands are referenced by name, e.g. $src1, $src2, $dst.
 - These names come from InOperandList and OutOperandList.

Order matters:
 - AT&T syntax → $src2, $src1, $dst
 - Intel syntax → $dst, $src1, $src2

This matches the conventions of each dialect:
 - AT&T: destination is last.
 - Intel: destination is first.

***** DONE corner cases to deal with
****** {${mask}}{z}
"v4fmaddps	{$src3, $src2, $dst {${mask}}|$dst {${mask}}, $src2, $src3}"
"v4fmaddps	{$src3, $src2, $dst {${mask}} {z}|$dst {${mask}} {z}, $src2, $src3}"
${mask} is an optional mask register (k0–k7).
{z} optional keyword when the instruction supports the “zeroing” feature.
****** {1to8}
"vaddbf16	{${src2}{1to8}, $src1, $dst {${mask}} {z}|$dst {${mask}} {z}, $src1, ${src2}{1to8}}"
${src2}{1to8} → broadcast form of a memory operand
  - Meaning: take a scalar memory element and replicate (broadcast) it across all lanes of the destination vector.
{1to16}
{1to32}
(vaddbf16 dst src1 (broadcast src2 :factor 8) &optional mask zeroing?)
encoding:
 broadcast → encoded in EVEX.b + SAE bits, etc.
 mask → EVEX.aaa
 zeroing → EVEX.Z

hints in json, operand types:
 src2 of type bcst / i16mem_bcst / f32mem_bcst etc.
 i16mem (normal memory)
 i16mem_bcst (broadcast-capable memory)
 That _bcst suffix is the canonical hint that the operand can accept {1toN}.
****** {sae}
"vcmppd	{$cc, {sae}, $src2, $src1, $dst|$dst, $src1, $src2, {sae}, $cc}"

In TableGen, {sae} comes from special AsmOperandClass (like SAE or EVEX_SAE)
It’s basically a flag → if present, set an EVEX bit (EVEX.b = 1) in the final encoding.
**** FormBits and form
is a bitmask representing properties of the instruction’s operand layout.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrFormats.td
https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/X86RecognizableInstr.h#L99

enum {
  Pseudo          = 0,
  RawFrm          = 1,
  AddRegFrm       = 2, // add register into the 3 low bits of the opcode
  RawFrmMemOffs   = 3,
  RawFrmSrc       = 4,
  RawFrmDst       = 5,
  RawFrmDstSrc    = 6,
  RawFrmImm8      = 7,
  RawFrmImm16     = 8,
  MRMDestMem      = 32,
  MRMSrcMem       = 33,
  MRMSrcMem4VOp3  = 34,
  MRMSrcMemOp4    = 35,
  MRMXm           = 39,
  MRM0m..MRM7m    = 40..47,
  MRMDestReg      = 48,
  MRMSrcReg       = 49,
  MRMSrcReg4VOp3  = 50,
  MRMSrcRegOp4    = 51,
  MRMXr           = 55,
  MRM0r..MRM7r    = 56..63,
  // ... followed by MRM_C0..MRM_FF for hex opcode forms 64..126 etc.
};

***** decoding table
RawFrm family (implied / fixed operands)
| Form              | Example Mnemonics                     | Meaning for assembler generator                        | What to do with JSON operands |
| ----------------- | ------------------------------------- | ------------------------------------------------------ | ----------------------------- |
| **RawFrm**        | `nop`, `clc`, `cbw`, `cdq`            | Pure opcode, no operands.                              | Ignore `$src`/`$dst`.         |
| **RawFrmImm8**    | `int imm8`, `enter imm16, imm8`       | Has 8-bit immediate.                                   | Keep `i8imm`.                 |
| **RawFrmImm16**   | `enter imm16, imm8` (imm16 part)      | Has 16-bit immediate.                                  | Keep `i16imm`.                |
| **RawFrmImm32**   | Far `call imm32`, `jmp imm32`         | Has 32-bit immediate.                                  | Keep `i32imm`.                |
| **RawFrmDstSrc**  | `cmpsb/w/d/q`, `movsb/w/d/q`          | No explicit operands: implicit `(E)SI→(E)DI`.          | Ignore `$src`/`$dst`.         |
| **RawFrmDst**     | `stosb/w/d/q`, `scasb/w/d/q`          | No explicit operands: implicit `AL/AX/EAX` → `[EDI]`.  | Ignore `$dst`.                |
| **RawFrmSrc**     | `lodsb/w/d/q`                         | No explicit operands: implicit `[ESI]` → `AL/AX/EAX`.  | Ignore `$src`.                |
| **RawFrmMemOffs** | `mov al, [imm32]`, `mov [imm32], eax` | Memory is encoded as absolute displacement, no ModR/M. | Keep `offset32`.              |


MRM family (special ModR/M encodings; the instruction is distinguished by the ModR/M reg field (bits 3–5), not by opcode alone.)
| Form              | Example Mnemonics            | Meaning                                                      | Assembler generator action                                              |
| ----------------- | ---------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------------------- |
| **MRM0r–MRM7r**   | `TEST r/m32, r32` variants   | The `/r` field in ModR/M is used as opcode extension 0–7.    | JSON already expands them. Treat like normal ModR/M form.               |
| **MRM0m–MRM7m**   | `TEST r/m8, imm8` (etc.)     | Same as above, but operand is memory.                        | Normal ModR/M handling.                                                 |
| **MRM\_C0**       | `xlat`, some `FPU` ops       | Fixed reg field = `000b`. No explicit operand.               | Assembler should expose zero operands.                                  |
| **MRM\_0F**       | All `0F xx` two-byte opcodes | Means this opcode uses `0F` escape prefix.                   | Treat normally; JSON gives operands.                                    |
| **MRM\_C1, C2 …** | Many FPU instructions        | Opcode group distinguished by ModR/M reg field = 001b, 010b… | Usually no operands (implicit ST registers). Ignore JSON `$src`/`$dst`. |

MRMXr means:
 - Instruction encoding uses a ModR/M byte.
 - The reg field of ModR/M is fixed to some constant (the opcode extension).
 - The operand is a register (rm = reg).

others:
| Form                 | Example Mnemonics                        | Meaning                                                        | Assembler action                                      |
| -------------------- | ---------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------- |
| **MRM\_C8 … CF**     | FPU register stack ops like `fxch st(i)` | Operands encoded in ModR/M reg field, but always ST registers. | Sometimes JSON shows `dstidx8/srcidx8`. Map to ST(i). |
| **MRM\_Int**         | `INT imm8`                               | Encoded with opcode `CD` + imm8.                               | Same as RawFrmImm8 (alias).                           |
| **MRM\_SI/DI**       | `MOVS`, `CMPS`, etc.                     | Implied source/dest pointers (string ops).                     | Same as RawFrmDst/Src.                                |
| **MRM\_Op3A, Op3B…** | `0F 3A xx`, `0F 3B xx`                   | Extra opcode map (VEX/SSSE3 instructions).                     | Normal operand handling; prefix distinguishes them.   |
***** etc
1. Raw Forms (no ModR/M):
   RawFrm, RawFrmMemOffs, RawFrmSrc, RawFrmDst, RawFrmDstSrc, RawFrmImm8, RawFrmImm16: used for immediate forms or memory offsets without ModR/M.

2. AddReg Forms:
   AddRegFrm: register encoded in low opcode bits (e.g., INC r, DEC r).

3. ModR/M Forms:
   MRMDestMem, MRMSrcMem, MRMDestReg, MRMSrcReg, plus their vector extensions (4VOp3, Op4).

4. Fixed opcode forms (/digit or fixed Reg in ModR/M):

   MRM0m–MRM7m, MRM0r–MRM7r: where /0.../7 are fixed sub-opcode encodings.
   And MRMXm, MRMXr: extended mappings.
   Plus MRM_C0..MRM_FF: hard-coded 2nd opcode or reg field mapping.
**** OpMap
| `OpMap`     | Legacy escape sequence     | Notes                                          |
| ----------- | -------------------------- | ---------------------------------------------- |
| **Default** | *(none)*                   | one-byte opcodes                               |
| **0F**      | `0F`                       | original two-byte map                          |
| **T8**      | `0F 38`                    | three-byte map 1                               |
| **TA**      | `0F 3A`                    | three-byte map 2                               |
| **T\_MAP4** | `0F 3A` (EVEX/VEX mm=100b) | semantically distinct map 4 (used for AVX-512) |
| **XOP8**    | `8F 08`                    | AMD XOP map 8                                  |
| **XOP9**    | `8F 09`                    | AMD XOP map 9                                  |
| **XOPA**    | `8F 0A`                    | AMD XOP map A                                  |
| **3DNow**   | `0F 0F` + imm8             | AMD 3DNow!                                     |

In VEX/EVEX prefixes, there are 3 bits (mm) that select the opcode map.
LLVM exposes those as OpMap values.
| `mm` bits | LLVM `OpMap` | Legacy escape sequence | Notes                       |
| --------- | ------------ | ---------------------- | --------------------------- |
| `000`     | **Default**  | 1-byte opcodes         | legacy / default map        |
| `001`     | **0F**       | `0F`                   | two-byte opcodes            |
| `010`     | **T8**       | `0F 38`                | three-byte map 1            |
| `011`     | **TA**       | `0F 3A`                | three-byte map 2            |
| `100`     | **T\_MAP4**  | `0F 3A` (EVEX only)    | distinct map 4 (VNNI, etc.) |
| `101`     | **T\_MAP5**  | EVEX only              | reserved / future Intel use |
| `110`     | **T\_MAP6**  | EVEX only              | reserved / future Intel use |
| `111`     | **T\_MAP7**  | EVEX only              | reserved / future Intel use |

**** TSFlags
https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h#L692

(set-flag :form-bits  (pop-bits 7)) ; 0-7
(set-flag :op-size    (pop-bits 2)) ; 8-9
(set-flag :ad-size    (pop-bits 2)) ; 10-11
(set-flag :op-prefix  (pop-bits 2)) ; 12-13
(set-flag :op-map     (pop-bits 4)) ; 14-17
(set-flag :rex        (pop-bits 1)) ; 18
(set-flag :imm        (pop-bits 4)) ; 19-22
(set-flag :fp-type    (pop-bits 3)) ; 23-25
(set-flag :lock       (pop-bits 1)) ; 26
(set-flag :rep        (pop-bits 1)) ; 27
(set-flag :sse-domain (pop-bits 2)) ; 28-29
(set-flag :encoding   (pop-bits 2)) ; 30-31
(let ((opcode (pop-bits 8)))        ; 32-39
  ;; assert that the extracted json opcode is the same as the
  ;; one encoded into the tsflags.
  (assert (equal opcode (get-field :opcode))))

;; :vector contains all the rest of the flags for easy checking for complex instructions
(set-flag :vector     (json-bitfield-to-integer tsflags)) ; 40-

(set-flag :vex-4v     (pop-bits 1))
(set-flag :vex-l      (pop-bits 1))
(set-flag :evex-k     (pop-bits 1))
(set-flag :evex-z     (pop-bits 1))
(set-flag :evex-l2    (pop-bits 1))
(set-flag :evex-b     (pop-bits 1))
(set-flag :cd8-scale  (pop-bits 3))
(set-flag :evex-rc    (pop-bits 1))
(set-flag :no-track   (pop-bits 1))
(set-flag :explicit-op-prefix (pop-bits 2))
(set-flag :evex-nf    (pop-bits 1))
(set-flag :two-conditional (pop-bits 1))
(set-flag :evex-u     (pop-bits 1))
**** X86II::getOperandBias(Desc)
returns an integer offset telling the emitter where the first “real” operand starts in the instruction’s operand list.

https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86InstrInfo.cpp
**** corner cases
***** constraints
search for: constraints": "[^"]
		"!name": "ADC32rr_REV",
		"Constraints": "$src1 = $dst",
**** parsing json
streaming API is a must because the file is 147MB (222 pretty printed)
 which disqualifies most CL json parsers

https://sabracrolleton.github.io/json-review#decoding
https://github.com/sabracrolleton/sabracrolleton.github.io/

probably i should have picked this one instead of json-streams:
https://github.com/Zulu-Inuoe/jzon#streaming-parser-example
*** fake instructions
ADDR16_PREFIX
LOCK_PREFIX
REP_PREFIX
REPE_PREFIX
REPNE_PREFIX
DATA16_PREFIX
CS_PREFIX
DS_PREFIX
FS_PREFIX
GS_PREFIX
SS_PREFIX
* etc
** interested parties
https://github.com/phantomics/specops/discussions/2
** useful #command lines
echo -n 'f3 90' | xxd -r -p | ndisasm -b 64 -
cat test.asm && nasm test.asm && hexdump --canonical test
